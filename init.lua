if vim.loader then vim.loader.enable() end; vim.g.loaded_netrw = 1; vim.g.loaded_netrwPlugin = 1; vim.g.mapleader = " "; local opt = vim.opt
for k, v in pairs({ number = true, relativenumber = true, numberwidth = 4,
    signcolumn = "yes",
    tabstop = 4, softtabstop = 4, shiftwidth = 4, expandtab = true,
    smartindent = true, breakindent = true,
    list = true, listchars = { tab = "  ", trail = "·", extends = "›", precedes = "‹", nbsp = "␣" }, smartcase = true, hlsearch = false, incsearch = true,
    background = "dark", guicursor = "a:block",
    updatetime = 50, timeoutlen = 150,
    scrolloff = 8, sidescrolloff = 8,
    winborder = "rounded", clipboard = "unnamedplus",
    completeopt = { "menuone", "noselect" },
    conceallevel = 0, pumheight = 10, pumblend = 0,
    winblend = 0, swapfile = false, shada = "", ruler = false,
    title = true, titlelen = 0,
}) do opt[k] = v end ; opt.fillchars:append({ eob = " ", stl = " ", horiz = " ", horizup = " ", horizdown = " ", vertleft = " ", vertright = " ", verthoriz = " " }); local mini_path = vim.fn.stdpath("data") .. "/site/pack/deps/start/mini.nvim"; if vim.fn.empty(vim.fn.glob(mini_path)) > 0 then vim.fn.system({"git", "clone", "--depth", "1", "https://github.com/echasnovski/mini.nvim", mini_path}) end; vim.cmd("packadd mini.nvim"); local add = require("mini.deps").add; add({ source = "nvim-lua/plenary.nvim" }); add({ source = "ThePrimeagen/harpoon", checkout = "harpoon2" }); local harpoon = require("harpoon"); harpoon:setup(); local function safe_format() local ft=vim.bo.filetype local commands={python={cmd={"ruff","format"},clean={"ruff","clean"}},go={cmd={"gofmt","-w","%"},clean={"goimports","-w","%"}}} local fmt=commands[ft] if not fmt then vim.notify("No formatter for "..ft,vim.log.levels.WARN) return end local function run_command(command,on_success) if vim.fn.executable(command[1])~=1 then vim.notify("Missing executable: "..command[1],vim.log.levels.ERROR) return end vim.fn.jobstart(command,{stdout_buffered=true,stderr_buffered=true,on_exit=function(_,code) vim.schedule(function() if code==0 then if on_success then on_success() end else vim.notify(table.concat(command," ").." failed",vim.log.levels.ERROR) end end) end}) end run_command(fmt.cmd,function() if fmt.clean then run_command(fmt.clean,function() vim.cmd("edit!") vim.notify("Formatted and cleaned "..ft..", buffer reloaded",vim.log.levels.INFO) end) else vim.cmd("edit!") vim.notify("Formatted "..ft..", buffer reloaded",vim.log.levels.INFO) end end) end

for _, m in ipairs({
    { "n", "<leader>w", function() MiniTrailspace.trim() MiniTrailspace.trim_last_lines() vim.cmd.write() end, "+1 Trim & Save" }, { "n", "<leader>q", ":exit<CR>", "Quit" }, { "n", "<leader>wq", function() MiniTrailspace.trim() MiniTrailspace.trim_last_lines() vim.cmd("xa") end, "Save & Quit" },
    { "n", "<leader>a", function() harpoon:list():add() end, "Harpoon Add" },
    { "n", "<C-e>", function() require("harpoon").ui:toggle_quick_menu(require("harpoon"):list()) end, "Harpoon Menu" },
    { "n", "<C-h>", function() harpoon:list():select(1) end, "Harpoon 1" },
    { "n", "<C-t>", function() harpoon:list():select(2) end, "Harpoon 2" },
    { "n", "<C-n>", function() harpoon:list():select(3) end, "Harpoon 3" },
    { "n", "<C-s>", function() harpoon:list():select(4) end, "Harpoon 4" },
    { "n", "<leader>hx", function() require("harpoon"):list():clear() end, "Harpoon Clear" },
    { "n", "<leader>f", ":Pick files<CR>", "+4 Pick: Files" },
    { "n", "<leader>fg", ":Pick grep_live<CR>", "Pick: Grep" },
    { "n", "<leader>fw", function() MiniPick.builtin.grep({ pattern = vim.fn.expand("<cword>") }) end, "Pick: Word" },
    { "n", "<leader>fb", ":Pick buffers<CR>", "Pick: Buffers" },
    { "n", "<leader>fc", ":Pick colorschemes<CR>", "Pick: Colorschemes"},
    { "n", "<leader>h", ":Pick help<CR>", "+1 Pick: Help" },
    { "n", "<leader>e", ":Oil<CR>", "+1 Oil: Explorer" },
    { "n", "<leader>ef", function() MiniFiles.open() end, "MiniFiles" },
    { "n", "<leader>wz", function() MiniMisc.zoom() end, "Zoom Window" }, { "n", "<leader>wr", function() MiniMisc.resize_window() end, "Resize Window"}, { { "n", "x", "o" }, "<leader>j", function() MiniJump2d.start() end, "MiniJump2d: Start jump" },
    { "n", "<leader>lf", vim.lsp.buf.format, "LSP: Format" }, { "n", "<leader>l", function() end, "+1 Lsp" },
    { "n", "<leader>cm", ":Mason<CR>", "Open Mason" }, { "n", "<leader>c", function() end, "+2 Code Tools" },
    { "n", "<leader>bn", ":bn<CR>", "Next Buffer" },
    { "n", "<leader>bp", ":bp<CR>", "Prev Buffer" },
    { "n", "<leader>bd", ":bd<CR>", "Delete Buffer" },
    { "n", "<leader>bf", ":bd!<CR>", "Force Delete Buffer" }, { "n", "<leader>ba", ":%bw<CR>", "Wipeout All Buffers" },
    { "n", "<leader>d", function() vim.diagnostic.open_float(nil, { scope = "l" }) end, "+1 Show Diagnostic" }, { "n", "<leader>da", function() vim.diagnostic.setqflist({ open = true, title = "Diagnostics"}) end, "Show All Diagnostics"},
    { { "n", "v" }, "d", '"_d', "Delete (no yank)" },
    { { "n", "v" }, "c", '"_c', "Change (no yank)" },
    { "n", "x", '"_x', "Cut (no yank)" },
    { "n", "<C-p>", function() vim.cmd('botright split term://powershell') end, "Open PowerShell" }, { "n", "<leader>ca", safe_format, "Code Actions" },{ "n", "<leader>ti", function() vim.notify(string.format("Time: %s | Date: %s | %s", os.date("%I:%M:%S %p"), os.date("%Y-%m-%d"), os.date("%A")), vim.log.levels.INFO, { title = "Clock" }) end, "Time" },
    { "n", "<leader>gg", function() if vim.fn.executable("lazygit") == 1 then vim.cmd("botright split term://lazygit") else vim.notify("lazygit not found", vim.log.levels.WARN)end end, "Lazygit" }, { "n", "<leader>g", function() end, "+1 Git Integration" },
}) do vim.keymap.set(m[1], m[2], m[3], { desc = m[4] }) end

vim.pack.add({
    { src = "https://github.com/neovim/nvim-lspconfig" },
    { src = "https://github.com/mason-org/mason.nvim" },
    { src = "https://github.com/stevearc/oil.nvim" },
    { src = "https://github.com/echasnovski/mini.nvim" },
    { src = "https://github.com/vague2k/vague.nvim" },
    { src = "https://github.com/rose-pine/neovim" },
    { src = "https://github.com/folke/tokyonight.nvim" }, { src = "https://github.com/ellisonleao/gruvbox.nvim" },
    { src = "https://github.com/Saghen/blink.cmp" }, { src = "https://github.com/rafamadriz/friendly-snippets" },
})

require('blink.cmp').setup({ keymap = { ['<CR>'] = { 'accept', 'fallback' }, ['<Tab>'] = { 'select_next', 'fallback' }, ['<S-Tab>'] = { 'select_prev', 'fallback' }, ['<C-N>'] = { 'select_next', 'fallback' }, ['<C-P>'] = { 'select_prev', 'fallback' }, ['<C-K>'] = false, ['<C-Y>'] = false, ['<C-E>'] = false }, completion = { accept = { auto_brackets = { enabled = true } }, list = { selection = { preselect = true, auto_insert = false } }, menu = { border = 'rounded', winblend = 0 }, documentation = { auto_show = true, auto_show_delay_ms = 150 } }, sources = { default = { 'lsp', 'path', 'buffer', 'snippets' }, providers = { lsp = { module = 'blink.cmp.sources.lsp', score_offset = 100 }, path = { module = 'blink.cmp.sources.path', score_offset = 80 }, buffer = { module = 'blink.cmp.sources.buffer', score_offset = 70 }, snippets = { module = 'blink.cmp.sources.snippets', score_offset = 90 }, } }, fuzzy = { implementation = 'lua' }, signature = { enabled = true, trigger = { enabled = true }, window = { border = 'rounded', winblend = 0 } }, }); for k, v in pairs({BlinkCmpKindFunction={fg="#3b82f6", bg="#3b82f6", bold=true}, BlinkCmpKindMethod={fg="#2563eb", bg="#2563eb", bold=true}, BlinkCmpKindVariable={fg="#22c55e", bg="#22c55e"}, BlinkCmpKindConstant={fg="#16a34a", bg="#16a34a"}, BlinkCmpKindValue={fg="#15803d", bg="#15803d"}, BlinkCmpKindField={fg="#4ade80", bg="#4ade80"}, BlinkCmpKindProperty={fg="#86efac", bg="#86efac"}, BlinkCmpKindClass={fg="#eab308", bg="#eab308", bold=true}, BlinkCmpKindInterface={fg="#facc15", bg="#facc15", bold=true}, BlinkCmpKindStruct={fg="#ca8a04", bg="#ca8a04", bold=true}, BlinkCmpKindTypeParameter={fg="#fde047", bg="#fde047"}, BlinkCmpKindModule={fg="#f97316", bg="#f97316"}, BlinkCmpKindPackage={fg="#fb923c", bg="#fb923c"}, BlinkCmpKindKeyword={fg="#ec4899", bg="#ec4899"}, BlinkCmpKindOperator={fg="#db2777", bg="#db2777"}, BlinkCmpKindSnippet={fg="#f43f5e", bg="#f43f5e"}, BlinkCmpKindText={fg="#a3a3a3", bg="#a3a3a3"}, BlinkCmpKindString={fg="#d4d4d4", bg="#d4d4d4"}, BlinkCmpKindEnum={fg="#9333ea", bg="#9333ea"}, BlinkCmpKindEnumMember={fg="#a855f7", bg="#a855f7"}, BlinkCmpKindConstructor={fg="#0ea5e9", bg="#0ea5e9"}, BlinkCmpKindBoolean={fg="#06b6d4", bg="#06b6d4"}, BlinkCmpKindNumber={fg="#0891b2", bg="#0891b2"}}) do vim.api.nvim_set_hl(0, k, v) end
require("mason").setup(); require("oil").setup({ default_file_explorer = true, columns = { "icon" }, buf_options = { buflisted = false, bufhidden = "hide" }, win_options = { wrap = false, signcolumn = "no", cursorcolumn = false, foldcolumn = "0", spell = false, list = false, conceallevel = 3, concealcursor = "nvic" }, delete_to_trash = false, skip_confirm_for_simple_edits = false, prompt_save_on_select_new_entry = true, cleanup_delay_ms = 2000, lsp_file_methods = { enabled = true, timeout_ms = 1000, autosave_changes = false }, constrain_cursor = "editable", watch_for_changes = false, keymaps = { ["g?"] = { "actions.show_help", mode = "n" }, ["<CR>"] = "actions.select", ["<C-s>"] = { "actions.select", opts = { vertical = true } }, ["<C-h>"] = { "actions.select", opts = { horizontal = true } }, ["<C-t>"] = { "actions.select", opts = { tab = true } }, ["<C-p>"] = "actions.preview", ["<C-c>"] = { "actions.close", mode = "n" }, ["<C-l>"] = "actions.refresh", ["-"] = { "actions.parent", mode = "n" }, ["_"] = { "actions.open_cwd", mode = "n" }, ["`"] = { "actions.cd", mode = "n" }, ["~"] = { "actions.cd", opts = { scope = "tab" }, mode = "n" }, ["gs"] = { "actions.change_sort", mode = "n" }, ["gx"] = "actions.open_external", ["g."] = { "actions.toggle_hidden", mode = "n" }, ["g\\"] = { "actions.toggle_trash", mode = "n" }, q = "actions.close", l = "actions.select", h = "actions.parent", ["<leader>r"] = "actions.refresh" }, use_default_keymaps = true, view_options = { show_hidden = true, is_hidden_file = function(name, bufnr) local m = name:match("^%.") return m ~= nil end, is_always_hidden = function(name, bufnr) return false end, natural_order = "fast", case_insensitive = false, sort = { { "type", "asc" }, { "name", "asc" } }, highlight_filename = function(entry, is_hidden, is_link_target, is_link_orphan) return nil end }, extra_scp_args = {}, git = { add = function(path) return false end, mv = function(src_path, dest_path) return false end, rm = function(path) return false end }, float = { padding = 2, max_width = 0, max_height = 0, border = "rounded", win_options = { winblend = 0 }, get_win_title = nil, preview_split = "auto", override = function(conf) return conf end }, preview_win = { update_on_cursor_moved = true, preview_method = "fast_scratch", disable_preview = function(filename) return false end, win_options = {} }, confirmation = { max_width = 0.9, min_width = { 40, 0.4 }, width = nil, max_height = 0.9, min_height = { 5, 0.1 }, height = nil, border = "rounded", win_options = { winblend = 0 } }, progress = { max_width = 0.9, min_width = { 40, 0.4 }, width = nil, max_height = { 10, 0.9 }, min_height = { 5, 0.1 }, height = nil, border = "rounded", minimized_border = "rounded", win_options = { winblend = 0 } }, ssh = { border = "rounded" }, keymaps_help = { border = "rounded" } })

for _,m in ipairs({"ai","bracketed","bufremove","comment","diff","extra","git","icons","jump","jump2d","misc","move","pairs","snippets","splitjoin","surround","tabline","trailspace"}) do require("mini."..m).setup() end -- "completion",
MiniIcons.tweak_lsp_kind(); require("mini.notify").setup({ lsp_progress = { enable = true, duration_last = 250 }, window = { config = { border = "rounded" }, max_width_share = 0.6 } }) ; require("mini.indentscope").setup({ draw = { animation = require("mini.indentscope").gen_animation.quadratic({ easing = 'in-out', duration = 20 }) }, symbol = "│", options = { try_as_border = true } }); require("mini.hipatterns").setup({ highlighters = { fixme = { pattern = "%f[%w]()FIXME()%f[%W]", group = "MiniHipatternsFixme" }, hack = { pattern = "%f[%w]()HACK()%f[%W]", group = "MiniHipatternsHack" }, todo = { pattern = "%f[%w]()TODO()%f[%W]", group = "MiniHipatternsTodo" }, note = { pattern = "%f[%w]()NOTE()%f[%W]", group = "MiniHipatternsNote" }, hex_color = require("mini.hipatterns").gen_highlighter.hex_color() } }); require("mini.files").setup({ windows = { preview = true, width_focus = 50, width_nofocus = 15, width_preview = 25, }, }); local animate = require("mini.animate"); local cursor_anim_enabled = false; local function set_cursor_animation(e) local t = { cursor = { enable = e, timing = animate.gen_timing.quadratic({ easing = "out", duration = 75, unit = "total" }), path = function(d) local p = animate.gen_path.line({ predicate = function() return true end, max_step = 300 })(d) local l = 1; local r = {} for i = 1, #p do for o = 0, l - 1 do local c = p[i][1] - o; local col = p[i][2]; if c >= 0 then table.insert(r, { c, col }) end end end return r end } }; animate.setup(t); cursor_anim_enabled = e end; set_cursor_animation(false); local mode_map = {n="NORMAL", no="OP PENDING", nov="OP PENDING (VISUAL)", noV="OP PENDING (V-LINE)", ["no\22"]="OP PENDING (V-BLOCK)", niI="NORMAL (INSERT)", niR="NORMAL (REPLACE)", niV="NORMAL (V-REPLACE)", nt="TERMINAL", v="VISUAL", V="V-LINE", ["\22"]="V-BLOCK", s="SELECT", S="S-LINE", ["\19"]="S-BLOCK", i="INSERT", ic="INSERT (COMPL)", ix="INSERT (COMPL)", R="REPLACE", Rc="REPLACE (COMPL)", Rv="V-REPLACE", Rx="REPLACE (COMPL)", c="COMMAND", cv="VIM EX", ce="EX", r="PROMPT", rm="MORE", ["r?"]="CONFIRM", ["!"]="SHELL", t="TERMINAL"}; require("mini.statusline").setup({ use_icons = true, content = { active = function() local mode_code = vim.fn.mode() local mode_name = mode_map[mode_code] or mode_code local mode_hl_map = { n="MiniStatuslineModeNormal", no="MiniStatuslineModeNormal", nov="MiniStatuslineModeVisual", noV="MiniStatuslineModeVisual", ["no\22"]="MiniStatuslineModeVisual", niI="MiniStatuslineModeInsert", niR="MiniStatuslineModeReplace", niV="MiniStatuslineModeReplace", nt="MiniStatuslineModeTerminal", v="MiniStatuslineModeVisual", V="MiniStatuslineModeVisual", ["\22"]="MiniStatuslineModeVisual", s="MiniStatuslineModeSelect", S="MiniStatuslineModeSelect", ["\19"]="MiniStatuslineModeSelect", i="MiniStatuslineModeInsert", ic="MiniStatuslineModeInsert", ix="MiniStatuslineModeInsert", R="MiniStatuslineModeReplace", Rc="MiniStatuslineModeReplace", Rv="MiniStatuslineModeReplace", Rx="MiniStatuslineModeReplace", c="MiniStatuslineModeCommand", cv="MiniStatuslineModeCommand", ce="MiniStatuslineModeCommand", r="MiniStatuslineModePrompt", rm="MiniStatuslineModePrompt", ["r?"]="MiniStatuslineModePrompt", ["!"]="MiniStatuslineModeShell", t="MiniStatuslineModeTerminal" } local mode_hl = mode_hl_map[mode_code] or "MiniStatuslineModeNormal" local mode_section = "%#" .. mode_hl .. "# " .. mode_name .. " " local file = "%#MiniStatuslineFilename#  " .. (vim.fn.expand("%:t") ~= "" and vim.fn.expand("%:t") or "[No Name]") .. " " local branch = "" if vim.b.gitsigns_status_dict and vim.b.gitsigns_status_dict.head then branch = "%#MiniStatuslineGit#  " .. vim.b.gitsigns_status_dict.head .. " " end local errors=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.ERROR}) local warns=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.WARN}) local infos=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.INFO}) local hints=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.HINT}) local diagnostics="" if errors>0 then diagnostics=diagnostics.."%#MiniStatuslineError#  "..errors.." " end if warns>0 then diagnostics=diagnostics.."%#MiniStatuslineWarn#  "..warns.." " end if infos>0 then diagnostics=diagnostics.."%#MiniStatuslineInfo#  "..infos.." " end if hints>0 then diagnostics=diagnostics.."%#MiniStatuslineHint#  "..hints.." " end local ft=vim.bo.filetype~="" and vim.bo.filetype or "-" local enc=(vim.bo.fenc~="" and vim.bo.fenc) or vim.o.enc local ff=vim.bo.fileformat local file_info="%#MiniStatuslineFileinfo# "..ft.." "..enc.." "..ff.." " local pos="%#MiniStatuslinePosition# "..vim.fn.line(".")..":"..vim.fn.col(".").." " local pct="%#MiniStatuslinePercent# "..math.floor((vim.fn.line(".")/math.max(vim.fn.line("$"),1))*100).."%% " local left=table.concat({mode_section,branch,file,diagnostics}) local right=table.concat({file_info,pct,pos}) return left.."%="..right end, inactive=function() local file="%#MiniStatuslineFilename# "..(vim.fn.expand("%:t")~="" and vim.fn.expand("%:t") or "[No Name]").." " local pos="%#MiniStatuslinePosition# "..vim.fn.line(".")..":"..vim.fn.col(".").." " return file.."%="..pos end } }); local pick_border = function() local height = math.floor(0.618 * vim.o.lines) local width = math.floor(0.618 * vim.o.columns) return { anchor = 'nw', height = height, width = width, row = math.floor(0.5 * (vim.o.lines - height)), col = math.floor(0.5 * (vim.o.columns - width)), } end; require("mini.pick").setup({ window = { config = nil, prompt_caret = '█ ', prompt_prefix = '» ', }, }); MiniIcons.mock_nvim_web_devicons(); local lt_opts = { action = 'open', pair = '<>', neigh_pattern = '\r.',register = { cr = false }, }; MiniPairs.map('i', '<', lt_opts); local gt_opts = { action = 'close', pair = '<>', register = { cr = false } }; MiniPairs.map('i', '>', gt_opts); local mg = require("mini.git"); mg.enable(); local s = function(f) local d = mg.get_buf_data() if d and d.head then pcall(f) end end; vim.keymap.set("n", "<leader>gh", function() s(mg.show_range_history) end, { desc = "Git History" }); vim.keymap.set("n", "<leader>gc", function() s(mg.show_at_cursor) end, { desc = "Git Cursor" }); vim.keymap.set("n", "<leader>gd", function() s(mg.show_diff_source) end, { desc = "Git Diff" })

vim.notify = require("mini.notify").make_notify()

local lspconfig = require("lspconfig"); vim.lsp.enable({ "pyright", "ruff", "gopls", "rust_analyzer", "vtsls" }); vim.lsp.config("lua_ls", { settings = { Lua = { workspace = { library = vim.api.nvim_get_runtime_file("", true) } } } }); vim.lsp.config("gopls", { settings = { gopls = { analyses = { unusedparams = true, shadow = true }, staticcheck = true } } }); local rust_capabilities = vim.lsp.protocol.make_client_capabilities(); rust_capabilities.textDocument.completion.completionItem.snippetSupport = true; rust_capabilities.textDocument.completion.completionItem.resolveSupport = { properties = { "documentation", "detail", "additionalTextEdits" } }; lspconfig.rust_analyzer.setup({ capabilities = rust_capabilities, settings = { ["rust-analyzer"] = { cargo = { allFeatures = true }, checkOnSave = true, procMacro = { enable = true }, lens = { enable = true } } } }); vim.api.nvim_create_autocmd("LspAttach", { callback = function(ev) local client = vim.lsp.get_client_by_id(ev.data.client_id); if client then vim.api.nvim_buf_set_option(ev.buf, "omnifunc", "v:lua.vim.lsp.omnifunc"); if client:supports_method("textDocument/completion") then vim.lsp.completion.enable(true, client.id, ev.buf, { autotrigger = true }) end end end })
vim.api.nvim_set_keymap('i', 'jk', '<Esc>', { noremap = true, silent = true }); vim.diagnostic.config({ virtual_text = { prefix = "■", spacing = 4, hl_mode = "combine", format = function(d) return string.format("%s [%s]", d.message, d.source or d.code or "") end }, signs = true, underline = true, update_in_insert = false, severity_sort = true, float = { border = "rounded", header = "Diagnostic(s):", prefix = "● ", source = "always", focusable = true } }); vim.api.nvim_create_autocmd("BufEnter", { pattern = "*.rs", callback = function() local ok, _ = pcall(vim.lsp.buf.inlay_hint, 0, true) if not ok then end end })

require("gruvbox").setup({terminal_colors=true,undercurl=true,underline=true,bold=true,italic={strings=false,emphasis=false,comments=true,operators=false,folds=true},strikethrough=true,invert_selection=false,invert_signs=false,invert_tabline=false,inverse=true,contrast="dark",transparent_mode=false,dim_inactive=false,palette_overrides={dark0_hard="#1d2021",dark1="#282828",dark2="#32302f",dark3="#3c3836",dark4="#504945",light0="#fbf1c7",light1="#ebdbb2",light2="#d5c4a1",light3="#bdae93",light4="#a89984",bright_red="#fb4934",bright_green="#b8bb26",bright_yellow="#fabd2f",bright_blue="#83a598",bright_purple="#d3869b",bright_aqua="#8ec07c",bright_orange="#fe8019",neutral_red="#cc241d",neutral_green="#98971a",neutral_yellow="#d79921",neutral_blue="#458588",neutral_purple="#b16286",neutral_aqua="#689d6a",neutral_orange="#d65d0e",faded_red="#9d0006",faded_green="#79740e",faded_yellow="#b57614",faded_blue="#076678",faded_purple="#8f3f71",faded_aqua="#427b58",faded_orange="#af3a03",gray="#928374"},overrides={Normal={fg="#ebdbb2",bg="#1d2021"},Comment={fg="#928374",italic=true},CursorLine={bg="#282828"},CursorLineNr={fg="#fabd2f",bold=true},LineNr={fg="#665c54",bg="#1d2021"},StatusColumn={link="Normal"},Visual={bg="#3c3836"},StatusLine={fg="#282828", bg="#fabd2f", bold=true},StatusLineNC={fg="#a89984",bg="#3c3836"},VertSplit={fg="#504945"},Pmenu={fg="#ebdbb2",bg="#282828"},PmenuSel={fg="#282828",bg="#fabd2f",bold=true},Search={fg="#282828",bg="#fabd2f"},IncSearch={fg="#282828",bg="#fe8019"},MatchParen={fg="#fabd2f",bg="#3c3836",bold=true}}}); vim.api.nvim_create_autocmd("ColorScheme",{pattern="gruvbox",callback=function() vim.api.nvim_set_hl(0,"SignColumn",{bg="#1d2021"}) end}); require("vague").setup({ transparent = false, bold = true, italic = false }); require("rose-pine").setup({ variant = "auto", dark_variant = "main", dim_inactive_windows = true, extend_background_behind_borders = true, styles = { bold = true, italic = false, transparency = false }, groups = { border = "highlight_med", background = "base", panel = "surface", comment = "muted", link = "iris", punctuation = "subtle", error = "love", hint = "iris", info = "foam", warn = "gold", git_add = "foam", git_change = "rose", git_delete = "love", git_dirty = "rose", git_ignore = "muted", git_merge = "iris", git_rename = "pine", git_stage = "iris", git_text = "rose", head = "iris", hunk = "rose" } })

local transparency_enabled, current_scheme, idx = true, nil, 5; local schemes = {  "vague", "rose-pine-moon",  "tokyonight-night", "gruvbox",  "rose-pine-main" }; local apply_transparency = function() if transparency_enabled then for _, group in ipairs({ "Normal", "NormalFloat", "SignColumn", "VertSplit", "StatusLine", "StatusLineNC", "TabLine", "TabLineSel", "TabLineFill", "Pmenu", "PmenuSel", "PmenuSbar", "PmenuThumb", "CursorLine", "LineNr", "CursorLineNr", "MsgArea", "Folded", "FoldColumn" }) do vim.api.nvim_set_hl(0, group, { bg = "NONE" }) end end end; local set_colorscheme = function(name, notify) if not pcall(vim.cmd.colorscheme, name) then vim.notify("Colorscheme " .. name .. " not found", vim.log.levels.ERROR) return end if notify and name ~= current_scheme then vim.notify("Switched Colorscheme: " .. name, vim.log.levels.INFO) end current_scheme = name apply_transparency() end; vim.opt.undofile = true; local u = vim.fn.stdpath("state") .. "/undo"; vim.opt.undodir = u; vim.fn.mkdir(u, "p"); local t = u .. "/.last_cleanup"; local n = os.time(); local l = vim.fn.filereadable(t) == 1 and tonumber(vim.fn.readfile(t)[1]) or 0; if n - l > 86400 then for _, f in ipairs(vim.fn.glob(u .. "/*", true, true)) do if f ~= t then os.remove(f) end end; vim.fn.writefile({ tostring(n) }, t) end

vim.keymap.set("n", "<leader>t", function() idx = (idx % #schemes) + 1; set_colorscheme(schemes[idx], true) end, { desc = "UI: Cycle Colorschemes" }); vim.keymap.set("n", "<leader>tt", function() transparency_enabled = not transparency_enabled; set_colorscheme(current_scheme, false); vim.notify("Transparency: " .. (transparency_enabled and "Enabled" or "Disabled"), vim.log.levels.INFO) end, { desc = "Toggle Transparency" }); vim.keymap.set("n", "<leader>ta", function() set_cursor_animation(not cursor_anim_enabled); vim.notify("Cursor Animation " .. (cursor_anim_enabled and "Enabled" or "Disabled"), vim.log.levels.INFO) end, { desc = "Toggle cursor animation" })

set_colorscheme(schemes[idx], false)
